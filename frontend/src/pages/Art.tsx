import React, { useEffect, useState, useRef } from 'react'
import { FormatPainterFilled, HomeOutlined, ShareAltOutlined, DownloadOutlined, GlobalOutlined } from '@ant-design/icons';
import { Capacitor } from '@capacitor/core';
import { Divider, Button as AntButton, Avatar, FloatButton, message as msg, Modal, Form, Typography, Input, Segmented, Alert, Card, Space, Carousel, Skeleton, Result, Empty, Slider, Select } from 'antd';
import { useHistory } from 'react-router';
import { collection, query, where, orderBy, limit, onSnapshot, doc, serverTimestamp, setDoc, CollectionReference, DocumentData, addDoc } from 'firebase/firestore';
import { firestore, storage } from '../firebase';
import { uploadBytesResumable, getDownloadURL, ref as storeRef } from 'firebase/storage';
import ImageUploadModal from '../components/ImageUploadModal';
import { Share } from '@capacitor/share';
import Button from '@mui/joy/Button';
import { Browser } from '@capacitor/browser';
import { useModelSelector } from '../hooks/useModelSelector';
import { ModelSelector } from '../components/ModelSelector/ModelSelector';

const ArtCard = ({ key, result, type, message, senderName, profileUrl, actionType, publicUrl, status, error }: any) => {
    const history = useHistory();

    const download = () => {
        Browser.open({
            url: publicUrl
        });
    };

    const share = () => {
        Share.share({
            title: 'ðŸ¤¡ AI generated this image',
            text: 'Check out this image generated by Gpt++. Download app at to create yours',
            dialogTitle: 'ðŸ¤¡ AI generated this image',
            url: publicUrl
        }).catch((e) => msg.error(e.message));
    }

    const post = async () => {
        if (confirm("Are you sure you want to post this chat message publicly?")) {

            try {

                const feedData = {
                    publicUrl: publicUrl,
                    message: message,
                    actionType: actionType,
                    senderName: senderName,
                    profileUrl: profileUrl,
                    likes: 0,
                    gpt: [],
                    comments: 0,
                    shares: 0,
                    type: 'image',
                    isShared: false,
                    feedId: null,
                    meta: {
                        comments: [],
                        likes: [],
                        shares: []
                    },
                    timestamp: serverTimestamp()
                };
                const feedRef = collection(firestore, "feeds");
                await addDoc(feedRef, feedData);
                history.push('/gpt/feeds');
            } catch (error) {
                console.error("Error copying chat to feeds:", error);
            }
        }

    }
    return (
        <Card cover={status == 'new' ? <></> : type == 'Text To Image' ? <img src={result?.data[0]?.url} /> : (type == 'Refined' ? <Carousel
            draggable={true} arrows={true} >
            <div key={1}>
                <img src={publicUrl} />
            </div>
            <div key={2}>
                <img src={result?.data[0]?.url} />
            </div>
        </Carousel> : <></>)}
            actions={[
                <><Space direction='horizontal' onClick={() => post()}><GlobalOutlined />Post</Space></>,
                <><Space direction='horizontal' onClick={() => download()}><DownloadOutlined />Download</Space></>,
                <><Space direction='horizontal' onClick={() => share()}><ShareAltOutlined />Share</Space></>
            ]}
            className='identify-objects-card'
            key={key}

        > {status == 'new' && <Skeleton active />}
            {status == 'error' && <Result
                status="error"
                title="Unable to generate image"
                subTitle={`${error != undefined ? error.message : 'Unknown error as to why AI was unable to generate image. Please try again!!!'}`}
            />}
            <Card.Meta description={message} />
        </Card>
    )
}

export const Art = () => {
    const [showImageUploadModal, setShowImageUploadModal] = useState(false);
    const [type, setType] = useState('image');
    const [arts, setArts] = useState([]);
    const history = useHistory();
    const [showArt, setShowArtModal] = useState(false);
    const [user, setUser] = useState<any>();
    const [working, setWorking] = useState(false);
    const [message, setMessage] = useState('');
    const [actionType, setActionType] = useState('Text To Image');
    const [selectedImage, setSelectedImage] = useState<File | null>(null);
    const [editedImage, setEditedImage] = useState<File | null>(null);
    const [fileList, setFileList] = useState<any>([]);
    const [brushSize, setBrushSize] = useState(10);
    const canvasRef = useRef<HTMLCanvasElement | null>(null);
    const { isOpen, setIsOpen, providers, loading, selectModel, selectedModel } = useModelSelector({
        type: 'text-to-image',
        onSelect: (model) => {
            console.log('Selected Model:', model);
        },
        defaultModel: {
            id: 'dalle-e-3',
            name: 'OpenAI Dalle e',
            type: 'text-to-image',
            provider: {
                providerLogoUrl: 'https://firebasestorage.googleapis.com/v0/b/chatgptpp-7d9f2.appspot.com/o/icons%2Fopenai%2Fpng%2Fopenai-logomark.png?alt=media&token=6b39a1d6-3094-4680-a3b2-eae31e9db2ad',
                providerName: '',
                models: []
            }
        }
    });
    useEffect(() => {
        if (localStorage.getItem('subscribed') == null) {
            msg.error('Only subscribed users can use this feature');
            history.push('/gpt/chat');
        }
        let session: any;
        session = localStorage.getItem('session');
        session = JSON.parse(session);
        setUser(session);


        const chatRef = collection(firestore, 'arts');
        const q = query(chatRef, where('sessionId', '==', session?.sid), orderBy('timestamp', 'desc'), limit(10));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const art: any = [];
            snapshot.docs.map(async (doc) => {

                art.push({ ...doc.data(), id: doc.id });
            });

            setArts(art);
        });
        return () => {
            unsubscribe();
        };
    }, []);

    const sendMessage = async (mediaUrl: any, publicUrl: any) => {
        try {
            const chatRef = collection(firestore, 'arts');
            const newMessage = {
                status: 'new',
                mediaUrl,
                publicUrl,
                profileUrl: user?.profileUrl ? user.profileUrl : null,
                sender: user?.uid,
                sessionId: user?.sid,
                message: message,
                type: actionType,
                model: selectedModel,
                timestamp: serverTimestamp(),
            };
            await setDoc(doc(chatRef), newMessage);
        } catch (error) {
            console.error(error);
            msg.error("Failed to send message");
        } finally {
        }
    };

    const handleUpload = () => {
        setWorking(true);
        if (fileList.length > 0) {
            const promises = fileList.map((file: any) => {
                console.log("blob exists", file.blobData, file.blobData !== undefined);
                const storageRef = storeRef(
                    storage,
                    file.blobData !== undefined
                        ? `${type}/arts/${new Date().toISOString()}.${file.type}`
                        : `${type}/arts/${new Date().toISOString() + '_' + file.name}`
                );
                return uploadBytesResumable(storageRef, file.blobData !== undefined ? file.blobData : file.originFileObj);
            });

            Promise.all(promises)
                .then((results) => {
                    const storagePaths = results.map((result) => result.ref.fullPath); // get the full storage path to the uploaded file
                    console.log(storagePaths);

                    const mediaUrls = storagePaths.map((path) => storeRef(storage, path).fullPath); // get the media URL of the uploaded file using the storage path
                    const publicUrls = storagePaths.map((path) => getDownloadURL(storeRef(storage, path))); // get the public download URL of the uploaded file using the storage path

                    Promise.all([mediaUrls, publicUrls]).then(([mediaUrls, publicUrls]) => {
                        console.log(mediaUrls, publicUrls);
                        msg.success('Upload successful');
                        getDownloadURL(storeRef(storage, storagePaths[0])).then((resolvedPublicUrl) => {
                            sendMessage(mediaUrls[0], resolvedPublicUrl);
                        });
                    });
                })
                .catch((error) => {
                    console.error(error);
                    msg.error('Upload failed');
                })
                .finally(() => {
                    setWorking(false);
                });
        } else {
            sendMessage(null, null);
            setWorking(false);
        }
    };

    const handleUploadWithMask = async () => {

    }
    const removePointsOnImage = (e: React.MouseEvent<HTMLImageElement>) => {
        if (editedImage) {
            const canvas = document.getElementById('canvas') as HTMLCanvasElement;
            const ctx = canvas.getContext('2d');
            if (ctx) {
                const img = new Image();
                img.src = URL.createObjectURL(editedImage);
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const brushRadius = 10; // Adjust the brush radius as needed

                    const onMouseMove = (moveEvent: MouseEvent) => {
                        if (moveEvent.buttons > 0) {
                            const rect = canvas.getBoundingClientRect();
                            const x = moveEvent.clientX - rect.left;
                            const y = moveEvent.clientY - rect.top;

                            ctx.clearRect(x - brushRadius, y - brushRadius, brushRadius * 2, brushRadius * 2);

                        }
                        canvas.style.cursor = 'none';
                    };

                    const onMouseUp = () => {
                        canvas.removeEventListener('mousemove', onMouseMove);
                        canvas.removeEventListener('mouseup', onMouseUp);

                        canvas.toBlob((blob) => {
                            setEditedImage(
                                new File([blob as BlobPart], editedImage.name, {
                                    type: editedImage.type,
                                    lastModified: editedImage.lastModified,
                                })
                            );
                        });
                    };

                    canvas.addEventListener('mousemove', onMouseMove);
                    canvas.addEventListener('mouseup', onMouseUp);

                    // Append the canvas to a container element in your HTML
                    const container = document.getElementById('canvas-container');

                };
            }
        }
    };

    const loadImage = () => {
        // Append the canvas to a container element in your HTML
        if (editedImage) {
            const canvas = document.getElementById('canvas') as HTMLCanvasElement;
            const ctx = canvas.getContext('2d');
            if (ctx) {
                const img = new Image();
                img.src = URL.createObjectURL(editedImage);
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                }
            }
        }
    }
    const tryGenArt = () => {
        switch (actionType) {
            case 'Text To Image':
                sendMessage(null, null);
                break;
            case 'Transform':
                handleUpload();
                break;
            case 'Inpaint':

                break;
        }
        setMessage('');
        setShowArtModal(false);
        return
    }

    const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            setEditedImage(file);
            const img = new Image();
            img.src = URL.createObjectURL(file);
            img.onload = () => {
                const canvas = canvasRef.current;
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                    }
                }
            };
        }
    };

    const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
        if (e.buttons !== 1) return; // Only draw when mouse is clicked
        const canvas = canvasRef.current;
        if (canvas) {
            const ctx = canvas.getContext('2d');
            if (ctx) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                ctx.clearRect(x - brushSize / 2, y - brushSize / 2, brushSize, brushSize);
            }
        }
    };

    const handleGenerate = () => {
        const canvas = canvasRef.current;
        if (canvas) {
            canvas.toBlob((blob) => {
                if (blob) {
                    const maskedImage = new File([blob], 'masked.png', { type: 'image/png' });
                    // Handle the upload of the masked image
                }
            });
        }
    };

    return (

        <div className="identify-image-object-container">

            <Divider>
                <Space direction='horizontal'>
                    <AntButton style={{ margin: '1rem' }} icon={<FormatPainterFilled />} onClick={() => setShowArtModal(true)}>Generate</AntButton>
                    <AntButton style={{ margin: '1rem' }} icon={<HomeOutlined />} onClick={() => history.push('/gpt/chat')}>Home</AntButton>
                </Space>
            </Divider>
            <FloatButton icon={<FormatPainterFilled />} type="primary" onClick={() => setShowArtModal(true)}></FloatButton>
            <div style={{ textAlign: 'center', display: 'none', padding: '5px' }}>
                <iframe src="https://rcm-eu.amazon-adsystem.com/e/cm?o=2&p=12&l=ur1&category=piv&banner=1W89G1DNPNEYJHQBWMR2&f=ifr&linkID=a867cb31df6e0c4ae9f1d1b442ec64de&t=lonerai-21&tracking_id=lonerai-21" width="300" height="250" scrolling="no" style={{ border: "none" }} sandbox="allow-scripts allow-same-origin allow-popups allow-top-navigation-by-user-activation"></iframe>
            </div>
            <Empty
                style={{ display: arts.length == 0 ? 'inherit' : 'none' }}
                image={<img src="data:image/png;base64,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"></img>}
                imageStyle={{ height: 60 }}
                description={
                    <span>
                        No arts generated yet
                    </span>
                }
            >
                <Button color="neutral" onClick={() => setShowArtModal(true)}>Generate now</Button>
            </Empty>
            <div style={{ padding: '15px' }}>
                {
                    (arts.map((art: any, index) => (
                        <ArtCard {...art} key={index} senderName={user?.name} actionType={art.type} sender={user?.uid} profileUrl={user?.profileUrl ? user.profileUrl : null} />
                    )))
                }
            </div>
            <Modal
                footer={null}
                open={showArt}
                onCancel={() => setShowArtModal(false)}
                style={{ padding: '20px' }}
            >
                <div style={{ textAlign: 'center', marginBottom: '20px' }}>
                    {/* Model Selection Button */}
                    <Button onClick={() => setIsOpen(true)} style={{ backgroundColor: 'white', color: 'black', border: '1px solid #d9d9d9', borderRadius: '10px' }}>
                        {selectedModel ? (
                            <>
                                <Avatar src={selectedModel.provider?.providerLogoUrl} size="small" className="avatar" />
                                <span>{selectedModel.id}</span>
                            </>
                        ) : (
                            <span>Select Model</span>
                        )}
                    </Button>
                </div>
                <h2 style={{ textAlign: 'center' }}>Generate an Image Using AI</h2>
                <Segmented
                    options={['Text To Image', 'Transform', 'Inpaint']}
                    onChange={(e: any) => setActionType(e)}
                    block
                    style={{ marginBottom: '20px', border: '1px solid #d9d9d9', borderRadius: '4px' }}
                />
                {/* Model Selector Modal */}
                <ModelSelector
                    isOpen={isOpen}
                    onClose={() => setIsOpen(false)}
                    providers={providers}
                    loading={loading}
                    onSelect={(model) => {
                        selectModel(model);
                    }}
                />

                <Alert
                    type='info'
                    style={{ display: actionType === 'Text To Image' ? 'block' : 'none', marginBottom: '10px' }}
                    message='Allows you to create an original image given a text prompt.'
                />
                <Alert
                    type='success'
                    style={{ display: actionType === 'Transform' ? 'block' : 'none', marginBottom: '10px' }}
                    message='Allows you to generate a variation of a given image.'
                />
                <Alert
                    type='error'
                    style={{ display: actionType === 'Inpaint' ? 'block' : 'none', marginBottom: '10px' }}
                    message='Allows you to edit and extend an image by uploading a mask.'
                />
                <div style={{ display: actionType === 'Text To Image' ? 'block' : 'none', marginBottom: '20px' }}>
                    <Form.Item>
                        <Typography.Text>Start with a detailed description</Typography.Text>
                        <Input
                            type="text"
                            value={message}
                            onChange={(e) => setMessage(e.target.value)}
                            placeholder='An Impressionist oil painting of sunflowers in a purple vaseâ€¦'
                            style={{ marginTop: '10px' }}
                        />
                    </Form.Item>
                </div>
                <div style={{ display: actionType === 'Transform' ? 'block' : 'none' }}>
                    <Form.Item >
                        <Space direction='horizontal'>
                            <Button type='primary' onClick={(e) => { e.preventDefault(); setShowImageUploadModal(true); }} >Click to open image chooser</Button>
                            <Button onClick={() => setFileList([])}>Clear</Button></Space>
                        <br /><br />
                        {
                            fileList.map((file: any) => (
                                <img src={URL.createObjectURL(file.originFileObj)} width={'100%'} />
                            ))
                        }

                    </Form.Item>
                </div>
                <div style={{ display: actionType === 'Inpaint' ? 'block' : 'none' }}>
                    <Form.Item>
                        <Typography.Text>Select image</Typography.Text>
                        <Input type='file' onChange={handleImageUpload} />
                        <Slider
                            min={5}
                            max={50}
                            value={brushSize}
                            onChange={(value) => setBrushSize(value)}
                            style={{ margin: '20px 0' }}
                        />
                        <div id="canvas-container" style={{ width: '100%' }}>
                            <canvas
                                ref={canvasRef}
                                onMouseMove={handleMouseMove}
                                style={{ border: '1px solid #d9d9d9', width: '100%' }}
                            />
                        </div>
                    </Form.Item>
                </div>
                <ImageUploadModal
                    visible={showImageUploadModal}
                    onCancel={() => setShowImageUploadModal(false)}
                    onUpload={(e: any) => {
                        console.log(e);
                        setFileList(e);
                        setSelectedImage(e[0].originFileObj);
                        setEditedImage(e[0].originFileObj);
                        setShowImageUploadModal(false);
                        loadImage();
                    }}
                />
                <AntButton
                    block
                    type="primary"
                    onClick={() => tryGenArt()}
                    style={{ marginTop: '20px' }}
                >
                    Generate
                </AntButton>
            </Modal>
        </div>
    )
}

export default Art;


